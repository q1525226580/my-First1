<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta age="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 1.原型链继承： prototype 属性
        function xx() {
            this.name = '张三';
            this.sex = '男';
        }

        function ss(n, a) {
            this.age = n;
            this.son = a;
        }

        ss.prototype = new xx();
        ss.prototype.constructor = ss;
        var np = new ss(20, '王五');
        console.log(np.age, np.name, np.sex);
        console.log(np.constructor);


        // 2. 直接继承prototype
        function xx() {}
        xx.prototype.name = '张三';
        xx.prototype.sex = '男';

        function ss(n, a) {
            this.age = n;
            this.son = a;
        }

        ss.prototype = xx.prototype;
        ss.prototype.constructor = ss;
        var np = new ss(20, '王五');
        console.log(np.age, np.sex, np.name);
        console.log(np.constructor);
        ss.prototype.name = '小六';
        var mm = new xx();
        console.log(mm.name);


        // 3. 空对象作为中介
        function xx() {}
        xx.prototype.name = '张三';
        xx.prototype.sex = '男';

        function ww(n, a) {
            this.a = a;
            this.n = n;
        }

        function dd(parent, child) {
            function F() {}
            F.prototype = parent.prototype;
            child.prototype = new F();
            child.prototype.constructor = child;
        }
        dd(xx, ww);
        var np = new ww('tc', 20);
        console.log(np.name, np.sex)
        ww.prototype.name = '五菱';
        var gao_ = new xx();
        console.log(gao_.name);


        // 4. 构造函数绑定：call
        function ss(sex, name) {
            this.name_ = name;
            this.sex_ = sex;
        }

        function Son(n, son) {
            this.n_ = n;
            this.son_ = son;
            ss.call(this, '汤臣一品', '大众捷达');
        }
        var son_ = new Son('小宝', 20);
        console.log(son_.sex_);
        console.log(son_.name_);


        // 5. 构造函数绑定：apply
        function ss(sex, name) {
            this.name_ = name;
            this.sex_ = sex;
        }

        function Son(n, son) {
            this.n_ = n;
            this.son_ = son;
            ss.apply(this, ['汤臣一品', '大众捷达']);
        }
        var son_ = new Son('小宝', 20);
        console.log(son_.sex_);
        console.log(son_.name_);


        // 6. 组合继承
        function yy() {
            this.foot = 2;
            this.head = 1;
            this.favorColor = ["red", "yellow"];
        }
        yy.prototype.sayColor = function () {
            alert("Hello,我最爱的颜色是：" + this.favorColor);
        }

        function uu(age, no) {
            yy.call(this);
            this.age = age;
            this.no = no;
        }
        uu.prototype = new yy();
        uu.prototype.constructor = uu;
        stu1 = new uu('小明', 20);
        stu1.sayColor();


        // 7. 拷贝继承
        function yy() {}
        yy.prototype.foot = 2;
        yy.prototype.head = 1;
        yy.prototype.saySelf = function () {
            alert("Hello,我有：" + this.foot + "只脚和" + this.head + "个头");
        }

        function uu(age, no) {
            this.age = age;
            this.no = no;
        }

        function dd2(Child, Parent) {
            var p = Parent.prototype;
            var c = Child.prototype;
            for (var i in p) {
                c[i] = p[i];
            }
        }
        dd2(uu, yy);
        var stu1 = new uu("张三", "s001");
        stu1.saySelf();
    </script>
</body>

</html>
