<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /* 
      1.通过prototype属性
      2.直接继承prototype
      3.利用空对象作为中介
      4.构造函数 call/apply
      5.组合继承
      6.copy继承
    */

      function Pig(n) {
        this.name = n
        this.skill1 = '36变'
        this.skill2 = '吃很多'
      }

      function Monkey(n) {
        this.M_name = n
        this.M_skill1 = '72变'
        this.M_skill2 = '筋斗云'
      }
      // prototype：挂载在原型对象上的属性和方法，可以被实例对象所使用
      Pig.prototype = new Monkey('孙悟空')
      // 由于我们修改了 Pig的原型对象，导致了继承练紊乱的问题。手动修正回来
      Pig.prototype.constructor = Pig

      var p1 = new Pig('猪八戒')
      console.log(p1)
      console.log(p1.M_skill2)

      // constructor 属性：返回当前对象的构造函数
      // p1是由Pig构造函数创建出来的
      console.log(p1.constructor) //monkey
    </script>
  </body>
</html>
